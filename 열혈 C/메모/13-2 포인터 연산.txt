포인터 같은 경우에는 이해를 하고 활용을 하는 것이 좋다.

포인터 연산
포인터를 이용한 연산

*연산자 []연산자
포인터를 대상으로 +과 -도 가능함 += -=도 가능
포인터로 곱셉과 나누셈은 안됨

int* ptr = .....
ptr += 1; 이라고 한다면
ptr의 0x01이 들어가 있다고 쳤을 때
0x02가 되는 것이 아니라 0x01+4가 되어 0x05가 된다.

double* q = ......
q += 1;
q의 0x01이 들어있다고 하면
0x01 + 8이 되어 0x09가 되는 것이다.
이러면 감이 올것이다.

0x10에 -= 1을 하면
int형 포인터는 4가 감소되어 0x06이 된다.
double형 포인터는 8이 감소되어 0x02가 된다.

즉 type* ptr을 1증가하고 1감소할 때 증가하고 감소하는 값은
sizeof(type)의 값만큼 되는 것이다.

int형이면 sizeof(int)값 만큼 증가 감소하고
double형이면 sizeof(double)값 만큼 증가 감소한다.

int arr[3];
int* ptr = arr;
라는 코드가 있을 떄 ptr과 arr모두 arr[0]을 가리키고 있는ㄷ
여기서 *ptr++을 해준다면 4가 증가되어서
ptr이 arr[1]를 가리키게 된다.
그리고 *ptr = 20이라고 하면 arr[1]에 20이 저장이 된다.
*ptr++을 해주면 arr[2]로 넘어간다
여기서 *ptr-=2;를 해준다면 4*2인 8이 감소되어
arr[0]이 된다.

ptr+1이 가능하기때문에 arr+1도 가능함
하지만 arr는 상수이기 때문에 arr++은 안됨

중요한 결론
arr[i] == *(arr+i)
사실 arr[i] = 10를 연산할 때도
arr에 i만큼 더 해졌네? 그럼 arr의 주소값은 0x02이니
애가 sizeof(int)의 값만큼 더하면 0x06에다가 10을 넣어야 겠다
라고 이해를 하면된다.

원래 배열을 접근할 때는 *(arr+i)처럼 접근이 되지만
배열의 접근 편의성을 위해 arr[i]이렇게 접근해도 되도록 별도의 접근방식을 제시한 것이다.



