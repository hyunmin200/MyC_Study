문자열
" "이런 형식이고 마지막에 \0 null문자가 들어감

포인터 변수를 이용한 선언과
배열을 이용해 선언하는 방법을 배운다.

char str[20] = "abcd"; 이렇게 만들고

str = "def";
라고 하는것은 불가능

그러면 한차례 배열을 선언후 어떻게 바꾸나?
할 수 있는데 나중에 나온다.

왜 안되냐면
str 즉 배열의 이름은 포인터 상수 이기 때문에 값을 넣을 수 없다.

이런 문자열을 변수의 성향을 지니는 문자열이라고 한다.
이런 식으로 str[0] = 'F'로 바꿀 수 있다.
이런식으로 일부를 바꿀 수 있다.

char * str = "abcd";
이렇게 선언하는 것도 가능하다.
이런식에서는 공간을 마련해주지 않았기 때문에
자동으로 메모리공간에 저장이 된다.
그리고 이 문자열이 저장된 주소값이 저자리로 반환이 된다.
문자열의 주소값 즉 a의 주소값이 저장이 되는 것이다.

a라는 문자가 0x10에 저장이 됬다라고 하면
일단 대입연산이 진행 되기 전에 메모리공간에 저장이 된 후에
0x10이라는 주소값이 반환이 된다.

그래서 배열은 내가 만들어 놓은 공간에 문자열이 들어오는 것이고
포인터는 문자열이 만들어진 공간의 주소값만 받아 오는 것이다
그래서 포인터형은 자동으로 할당이 되기 때문에 상수이다.
int num = 3 + 4도 상수이기 때문에 3과 4가 할당이 먼저 되고 더해지는 것이다.
즉 상수형태의 문자열


그래서 수정이 나중에 필요할 것 같다 하면 배열을 사용하고
수정이 필요없다 하면 배열과 포인터중 하나를 골라서 사용하면 된다.

char *str = "Your team";
str = "Our team";
이렇게 하면 허용이 된다.
왜냐하면 공간을 마련하지 않으면 무조건 자동으로 할당이 되기 때문에
o의 주소값이 들어가게 된다.
가리키는 대상이 바뀌는 것이다.

char str[] = "Your team";
str = "Our team";
이렇게 하면 허용이 되지 않는다.
str은 상수의 성격을 띈다.
그래서 상수에는 저장을 못하기 때문에 허용이 되지 않는 것이다.

컴파일러에 따라 상수형태의 문자열인 포인터 문자열을 변수로 보는 컴파일러도 있는데
어떤 컴파일러에서는 되고 안되는데 이러한 것은
사용하면 안된다.


printf("Show your string");
큰따옴표로 묶여서 표현되는 문자열은 그 형태에 상고나없이
메모리 공간에 저장된 후 그 주소 값이 반환된다. 그래서
위처럼 사용한다면 위 문자열이 0x01번지에 저장되었다고 가정하였을 때
printf(0x01)이런 식으로 되는 것이다.
printf함수는 문자열을 통째로 전달받는 함수가 아닌,
문자열의 주소 값을 전달받는 함수라는 것이다.

그래서
WhoAreYou("Hyun");
이라는 함수를 본다면
저 함수의 매개변수가
char * str이라고 예측할 수 있다.