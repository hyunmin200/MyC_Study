int arr[2];
arr라는 배열의 이름에 정보가 담겨있다
배열의 이름은 배열의 첫번째 값의 주소를 지니는 상수가 된다.
즉 배열의 주소값을 의미한다.
arr -> arr[0] 이렇게 가리킨다.
하지만 ptr는 다른 곳을 가리킬 수 있다.

그렇기 때문에 ptr는 변수이지만 arr(배열)은 상수이다.

정리
배열의 이름은 배열의 첫번째 요소의 주소값을 지님
다만 가리키는 대상을 바꿀 수 없음

arr에도 *arr식으로 사용할 수 있다.
ptr과 arr은 완전히 동일하지만
변수와 상수라는 것만 다른 것이다.

이런 것이 가능한 이유는
포인터는 int형이라는 걸 가리키고 있기 때문에 가능하다.
배열은 어떻게 가능할까?
int arr[2];이
int를 가리킨다는 것이 되기때문에
int형이라는 걸 알수있기 때문에 가능하다.

그럼 arr도 포인터인가?
포인터이다.
배열의 이름이 첫번째 요소값의 주소를 가리키기 때문에

정리
*arr이라고 하면 arr[0](첫번째 요소)를 접근하는 것이다.

그래서 만약 이런게 선언이 되어 있으면
int arr[3] = {0, 0, 0};
*arr = 10;
{10, 0, 0}로 바뀐다는 것이다.



int arr[3] = {0, 1, 2}
printf .....
이런 식으로 하나씩 다 출력 해 보았을 때
배열의 이름고 첫 번째 요소가 똑같다는 것을 알 수 있다.

주소값 == 포인터 XX
주소값 + 대상의 정보 == 포인터 OO


int arr[3] = {15, 25, 35};
int* ptr = &arr[0];
이런식으로 값을 받아서
ptr[0]
ptr[1]
ptr[2]
이렇게 사용할 수도 있다.

1. 배열의 이름도 포인터 변수도 다 포인터이다.
2. 차이점으로 포인터변수는 바뀔 수 있고
   배열을 바뀔 수 없는 상수인 것이 차이점이다.
3. 배열의 이름을 가지고 할 수 있는 것은 포인터 변수로도 할 수 있고
   포인터 변수로 할 수 있는 것은 배열의 이름을 로도 할 수 있다.
즉 *연산 []연산 둘다 가능하다.
